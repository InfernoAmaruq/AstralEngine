local Component = GetService("Component", "Component")
local Physics = GetService("Physics", "Physics")

local World = {}

local CAPTUREFUNC = function(t, ...)
    local s = t
    if typeof(t) == "Entity" then
        s = t:GetComponent("World")
    end
    local FUNC, WORLD = rawget(s, ".NEXTCALL"), rawget(s, "World")
    return FUNC(WORLD, ...)
end

local Functions = {
    Raycast = function(WorldTab, Start, End, Parameters, Out)
        Parameters = Parameters or Physics.RaycastParams.Default

        if not Parameters.GetFirst then
            Out = Out or {}
            Parameters.__OUT = Out
        end

        local ReleaseFunc = Physics.QueryData.Release

        WorldTab.World:raycast(Start, End, Parameters[".Tags"], Parameters.Callback)

        if Parameters.GetFirst then
            local Obj = Parameters.__OUT or Physics.QueryData.New()
            ReleaseFunc(Obj)
            return Obj
        else
            Parameters.__OUT = nil
            for _, v in ipairs(Out) do
                ReleaseFunc(v)
            end
            return Out
        end
    end,
    Shapecast = function(WorldTab, Shape, ShapeSize, ShapeRotation, Start, End, Parameters, Out)
        Parameters = Parameters or Physics.RaycastParams.Default

        if not Parameters.GetFirst then
            Out = Out or {}
            Parameters.__OUT = Out
        end

        local ReleaseFunc = Physics.QueryData.Release

        local TypeOf = typeof(ShapeRotation)
        local Quat = TypeOf == "Quat" and ShapeRotation

        if not Quat then
            if TypeOf == "Vec4" then
                Quat = quat(ShapeRotation:unpack())
            elseif TypeOf == "Vec3" then
                Quat = quat():setEuler(ShapeRotation:unpack())
            end
        end

        local RawShape = Physics.RaycastParams.GetTempShape(Shape, ShapeSize)

        WorldTab.World:shapecast(RawShape, Start, End, Quat, Parameters[".Tags"], Parameters.Callback)

        if Parameters.GetFirst then
            local Obj = Parameters.__OUT or Physics.QueryData.New()
            ReleaseFunc(Obj)
            return Obj
        else
            Parameters.__OUT = nil
            for _, v in ipairs(Out) do
                ReleaseFunc(v)
            end
            return Out
        end
    end,
    Overlap = function(WorldTab, Shape, ShapeSize, Position, ShapeRotation, Parameters, MaxDistance, Out)
        Parameters = Parameters or Physics.RaycastParams.Default

        Out = Out or {}
        Parameters.__OUT = Out

        local ReleaseFunc = Physics.QueryData.Release

        local TypeOf = typeof(ShapeRotation)
        local Quat = TypeOf == "Quat" and ShapeRotation

        if not Quat then
            if TypeOf == "Vec4" then
                Quat = quat(ShapeRotation:unpack())
            elseif TypeOf == "Vec3" then
                Quat = quat():setEuler(ShapeRotation:unpack())
            end
        end

        local RawShape = Physics.RaycastParams.GetTempShape(Shape, ShapeSize)

        WorldTab.World:overlapShape(RawShape, Position, Quat, MaxDistance, Parameters[".Tags"], Parameters.Callback)

        Parameters.__OUT = nil
        for _, v in ipairs(Out) do
            ReleaseFunc(v)
        end
        return Out
    end,
    QueryBox = function() end,
    QuerySphere = function() end,
}

local AliasMap = {
    Update = "update",
    Interpolate = "interpolate",
}

local WORLDINHERITANCE = {
    __index = function(t, k)
        if Functions[k] then
            return Functions[k]
        end

        k = rtype(k) == "string" and AliasMap[k] or k
        local W = rawget(t, "World")
        local v = W and W[k]

        if k == "Gravity" then
            return t.World:getGravity()
        end

        if rtype(v) == "function" then
            rawset(t, ".NEXTCALL", v)
            return CAPTUREFUNC
        else
            return v or rawget(t, k)
        end
    end,
    __newindex = function(t, k, v)
        if k == "Gravity" then
            t.World:setGravity(v)
            return
        end
        error("CANNOT WRITE TO WORLD", 2)
    end,
}

World.Name = "World"
World.Pattern = { update = 0, World = 0, WorldId = 0 }
World.Metadata = {}

local function HasTag(World, Name)
    local t = World.TagLookUp[Name]
    return t ~= nil
end

local function IsStatic(World, Tag)
    local t = table.find(World.StaticTags, Tag)
    return t and true or false
end

World.Metadata.__create = function(DATA)
    local T = {}
    T.World = DATA.W
    T.DefaultTag = DATA.D
    T.WorldId = DATA.N
    T.Tags = DATA.TAGS
    T.TagLookUp = {}
    T.StaticTags = DATA.STATIC

    for _, v in pairs(DATA.TAGS) do
        T.TagLookUp[v] = true
    end

    T.HasTag = HasTag
    T.IsStaticTag = IsStatic

    setmetatable(T, WORLDINHERITANCE)
    return T
end

World.Metadata.__remove = function(self, e)
    local Ent = GetService("World").GetEntityFromId(e)

    local MW = Physics.GetMainWorld()

    local w = self.World

    Physics.DestroyWorld(Ent, false, true)

    if w == MW then
        Physics.SetMainWorld(nil)
    end

    w:destroy()
    w:release()
end

return World
