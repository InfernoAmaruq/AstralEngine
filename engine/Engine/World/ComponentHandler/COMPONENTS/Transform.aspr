local Component = GetService("Component","Component")
local Physics = GetService("Physics","Physics")
local Transform = {}

Transform.Name = "Transform"
Transform.FastFetch = {
    "Position", "Orientation", "Rotation", "Matrix", "LocalOrientation", "LocalPosition", "LocalRotation", "LocalMatrix"
}
Transform.Pattern = {
    Position = Vec3,
    Orientation = Quat,
    Rotation = Vec3,
    Matrix = Mat4,
    FromPose = 0,
    LocalPosition = Vec3,
    LocalOrientation = Quat,
    LocalRotation = Vec3,
    LocalMatrix = Mat4,
}
Transform.Metadata = {}

Component.TransformRequired = {}

@flag{
    PosIdx = 1,
    OriIdx = 2,
    MatIdx = 3,
    RotIdx = 4,

    Self = 9,
}

local FIELDS = {
    Position = 1,
    Orientation = 2,
    Matrix = 3,
    Rotation = 4,
}

local function GetOrientation(Comp)
    local O = Comp[4]
    local x,y,z = math.rad(O.x),math.rad(O.y),math.rad(O.z)
    Comp[2]:setEuler(y,x,z)
    return Comp[2]
end

local function GetMatrix(Comp)
    Comp[3]:set(Comp[1], Comp[2])
    return Comp[3]
end

local function FromPose(T, x, y, z, a, ax, ay, az)
    local P, O, M, R = T[1], T[2], T[3], T[4]
    P:set(x, y, z)
    O:set(a, ax, ay, az)
    M:set(P, O)
    local ex, ey, ez = O:getEuler()
    R:set(ex, ey, ez)
end

local BaseMethods = {
    FromPose = FromPose,
    GetOrientation = GetOrientation,
    GetMatrix = GetMatrix,
}

local function GetVector(self,Type)
    local V = Type == "UpVector" and vec3.up or (Type == "RightVector" and vec3.right) or vec3.forward

    return (self[2] * V):normalize()
end

local function __INDEX(T, k)
    if k == "UpVector" or k == "RightVector" or k == "ForwardVector" then
        return GetVector(T,k)
    end
    local KEY = FIELDS[k]
    if KEY then
        if KEY == 1 or KEY == 4 then
            return vec3(T[KEY])
        elseif KEY == 2 then
            return quat(T[KEY])
        elseif KEY == 3 then
            return mat4(T[KEY])
        end
    else
        return BaseMethods[k]
    end
end

local function __NEWINDEX(Ret, k, v)
    if rtype(v) == "userdata" and v.type and v.type() then
        local F = FIELDS[k]
        if not F then
            return
        end
        Ret[F]:set(v:unpack())
    else
        if not FIELDS[k] then
            return
        end
        rawset(Ret, FIELDS[k], v)
    end

    if k == "Rotation" then
        GetOrientation(Ret)
    elseif k == "Orientation" then
        Ret[4]:set(Ret[3]:getEuler())
    end
    if k ~= "Matrix" then
        GetMatrix(Ret)
    end

    local Col = HasCollider(Ret[9])
    if Col then
        Physics.QueueToSyncLTJ(Col.WId,Col.ColRef,Ret)
    end
end

local MT = {__index = __INDEX, __newindex = __NEWINDEX}

@macro<L>:HasCollider(&E) = Component.HasComponent(&E,"Collider")

Transform.Metadata.__remove = function(self, EId, Forced)

    if Component.TransformRequired and not Forced then
        for _, Name in ipairs(Component.TransformRequired) do
            AstralEngine.Assert(not Component.HasComponent(EId,Name), "CANNOT REMOVE TRANSFORM COMPONENT. ENTITY HAS DEPENDENT COMPONENT", "TRANSFORM", 3)
        end
    end

    for i in pairs(self) do
        self[i] = nil
    end
end

Transform.Metadata.__create = function(DATA, Entity)
    local Ret = {[9] = Entity}

    if DATA then
        for i, v in pairs(DATA) do
            if not Transform.Pattern[i] then
                continue
            end
            if FIELDS[i] then
                local Type = typeof(v)
                local Wrap = Type == "Vec3" or Type == "Quat" or Type == "Mat"
                Ret[FIELDS[i]] = Wrap and Transform.Pattern[i](v) or v
            end
        end
    end

    for i, v in pairs(Transform.Pattern) do
        if (FIELDS[i] and Ret[FIELDS[i]]) then
            continue
        end
        if FIELDS[i] then
            Ret[FIELDS[i]] = type(v) == "function" and v() or v
        end
    end

    GetOrientation(Ret)
    GetMatrix(Ret)

    return setmetatable(Ret,MT)
end

return Transform
