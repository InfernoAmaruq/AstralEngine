local Physics = GetService("Physics", "Physics")
local Component = GetService("Component", "Component")
local WorldSer = GetService("World","World")

local Signal = require("../../../Lib/Signal.lua")

local mt = {}

local INHM = ENUM({
    None = 0b00,
    Root = 0b01,
},"ColliderSizeInheritance")

local Collider = {
    Name = "Collider",
    Pattern = {},
    Metadata = mt,
}

-- FLAGS
@flag:IDX_T_DOF = 1;
@flag:IDX_R_DOF = 2;

@macro<L,!USEBRACK>{VALIDATEDOF(&OBJ) = local RDOF, TDOF = &OBJ[&IDX_R_DOF], &OBJ[&IDX_T_DOF]; if (RDOF == nil or RDOF == "") and (TDOF == nil or TDOF == "") then error("CANNOT SET ALL DEGREES OF FREEDOM TO NIL. USE STATIC OR ANCHORED COLLIDER") end}

local SHAREDT = {
    -- states
    SetTranslationDOF = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot change DOF on static collider!","COLLIDER")
        VALIDATEDOF(self)
        self.ColRef:setDegreesOfFreedom(v,self[&IDX_R_DOF])
        self[&IDX_T_DOF] = v
    end,
    SetRotationDOF = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot change DOF on static collider!","COLLIDER")
        VALIDATEDOF(self)
        self.ColRef:setDegreesOfFreedom(self[&IDX_T_DOF],v)
        self[&IDX_R_DOF] = v
    end,
    SetTag = function(self, v)
        self.ColRef:setTag(v)

        local IsStatic = self.WorldComp:IsStaticTag(v)
        Physics.UpdateSyncField(w.WorldId,self.ColRef,"Static",IsStatic)
    end,

    ResetMass = function(self)
        self.ColRef:resetMassData()
    end,

    -- shapes
    RemoveShape = function(self,Shape)
        AstralEngine.Assert(#self.ShapeList <= 1,"CANNOT REMOVE SHAPE FROM COLLIDER. COLLIDER CANNOT HAVE ZERO SHAPES","COLLIDER")
        self.ConRef:removeShape(Shape.__ShapePtr)
        table.remove(self.ShapeList,table.find(self.ShapeList,Shape))
    end,
    AddShape = function(self,Shape)
        self.ColRef:addShape(Shape.__ShapePtr)
        table.insert(self.ShapeList(Shape))
    end,
    GetRootShape = function(self)
        return self.ShapeList[1]
    end,
    GetShapes = function(self)
        return self.ShapeList
    end,

    -- phys
    ApplyForce = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot apply force to static collider!","COLLIDER")
        self.ColRef:applyForce(v)
    end,
    ApplyTorque = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot apply force to static collider!","COLLIDER")
        self.ColRef:applyTorque(v)
    end,
    ApplyImpulse = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot apply impulse to static collider!","COLLIDER")
        self.ColRef:applyLinearImpulse(v)
    end,
    ApplyAngularImpulse = function(self, v)
        AstralEngine.Assert(not self.IsStatic,"Cannot apply impulse to static collider!","COLLIDER")
        self.ColRef:applyAngularImpulse(v)
    end,

    MoveKinematic = function(self,Pos,Angle,dt)
        local Quat

        if dt <= 0.01 then return end

        if typeof(Angle) == "Vec3" then
            Quat = quat():setEuler(Angle:unpack())
        else
            Quat = Angle or quat.identity
        end

        self.ColRef:moveKinematic(Pos,Quat,dt)
    end,

    OnDrawComponentResize = function(self,v)
        if self.OnResize then
            self:OnResize(v)
        end
        if self.InheritanceMethod.RawValue & INHM.Root.RawValue ~= 0 then
            self.ShapeList[1]:SetSize(v)
            self.ColRef:setAwake(true)
        end
    end
}

local function CALLFUNC(self, ...)
    return self[".NEXTCALL"](self.ColRef, ...)
end

local LIST = {
    RotationDOF = &IDX_R_DOF, TranslationDOF = &IDX_T_DOF,
}

local DirectGetters = {
    Continuous = "isContinuous",
    Enabled = "isEnabled",
    Tag = "getTag",
    Trigger = "isSensor",
    Kinematic = "isKinematic",
    Awake = "isAwake",
    GravityScale = "getGravityScale",
    CanSleep = "isSleepingAllowed",
    AutomaticMass = "getAutomaticMass",
    Inertia = "getInertia",
    Mass = "getMass",
    Restitution = "getRestitution",
    Friction = "getFriction",

    AngularDamping = "getAngularDamping",
    LinearDamping = "getLinearDamping",
}

local DirectSetters = {
    Continuous = "setContinuous",
    Enabled = "setEnabled",
    Trigger = "setSensor",
    Awake = "setAwake",
    GravityScale = "setGravityScale",
    CanSleep = "setSleepingAllowed",
    CenterOfMass = "setCenterOfMass",
    AutomaticMass = "setAutomaticMass",
    Inertia = "setInertia",
    Mass = "setMass",
    Restitution = "setRestitution",
    Friction = "setFriction",
    Kinematic = "setKinematic",

    AngularDamping = "setAngularDamping",
    LinearDamping = "setLinearDamping",

    AngularVelocity = "setAngularVelocity",
    LinearVelocity = "setLinearVelocity"
}

local FIELDTOFUNC = {
    RotationDOF = SHAREDT.SetRotationDOF,
    TranslationDOF = SHAREDT.SetTranslationDOF,
    Tag = SHAREDT.SetTag,
}

local GETTERS = {
    Static = function(self)
        return self.WorldComp:IsStaticTag(self.ColRef:getTag())
    end,
    AngularVelocity = function(self)
        return vec3(self.ColRef:getAngularVelocity())
    end,
    LinearVelocity = function(self)
        return vec3(self.ColRef:getLinearVelocity())
    end,
    CenterOfMass = function(self)
        return vec3(self.ColRef:getCenterOfMass())
    end,
}

local METATAB = {
    __index = function(self, k)
        local Col = self.ColRef
        local a = SHAREDT[k]
        if a then
            return a
        end
        local v = Col[k]
        if rtype(v) == "function" then
            rawset(self, ".NEXTCALL", v)
            return CALLFUNC
        end
        local DirectGetter = DirectGetters[k]
        if DirectGetter then
            return self.ColRef[DirectGetter](self.ColRef)
        end
        local Getter = GETTERS[k]
        if Getter then return Getter(self) end
        return v or (LIST[k] and rawget(self,LIST[k])) or rawget(self, k)
    end,
    __newindex = function(self, k, v)
        local DirectSetter = DirectSetters[k]
        if DirectSetter then
            return self.ColRef[DirectSetter](self.ColRef,v)
        end
        local Func = FIELDTOFUNC[k]
        if rtype(k) == "string" and Func then
            Func(self,v)
        else
            AstralEngine.Error("CANNOT WRITE TO COLLIDER FIELD: "..k,"COLLIDER",2)
        end
    end
}

function mt.__create(DATA, e)
    local Transform = assert(Component.HasComponent(e, "Transform"), "NO COMPONENT TYPE OF 'Transform' PRESENT, CANNOT ADD COLLIDER!")

    local EntPtr = WorldSer.GetEntityFromId(e)

    local World = DATA.World
    local WorldComp
    local WId

    if not World then
        WId = DATA.WorldId or 1
        World = assert(Physics.Worlds[WId], "NO WORLD WITH ID OF [" .. tostring(WId) .. "] PRESENT!")
    else
        WId = World.WorldId
    end

    WorldComp = Component.SetComponents[World.__id]["World"]

    local RawWorld = World:GetComponent("World").World

    local COLLIDER = RawWorld:newCollider(0,0,0)
    COLLIDER:setPose(Transform.Position,Transform.Orientation)
    COLLIDER:setTag(DATA.Tag or WorldComp.DefaultTag)

    local InheritanceMethod = DATA.InheritanceMethod or INHM.Root

    local Shapes = DATA.Shapes or {DATA.Shape or Physics.Shapes.NewShape(ENUM.ColliderShape.Box)}
    local Size = DATA.Size or Physics.GetObjSize(e)

    if InheritanceMethod.RawValue & INHM.Root.RawValue ~= 0 then
        Shapes[1]:SetSize(Size)
    end

    for _,v in ipairs(Shapes) do
        COLLIDER:addShape(v.__ShapePtr)
    end

    local IsStatic = WorldComp:IsStaticTag(COLLIDER:getTag())

    local Tab = {
        World = World,
        WorldComp = WorldComp,
        WId = WorldComp.WorldId,
        ColRef = COLLIDER,
        ShapeList = Shapes,
        Tags = 0,
        IsStatic = IsStatic,
        [&IDX_T_DOF] = DATA.TranslationDOF or "xyz",
        [&IDX_R_DOF] = DATA.RotationDOF or "xyz",
        Touched = Signal.new(Signal.Type.Default),
        TouchEnded = Signal.new(Signal.Type.Default),
        Entity = EntPtr,
        InheritanceMethod = InheritanceMethod
    }

    if not IsStatic then
        COLLIDER:setDegreesOfFreedom(Tab[&IDX_T_DOF],Tab[&IDX_R_DOF])
    end

    local T = setmetatable(Tab,METATAB)

    COLLIDER:setUserData(T)

    Physics.BindCollider(WId, T, Transform)

    if DATA.Trigger then
        T.ColRef:setSensor(true)
    end
    if DATA.Kinematic and not IsStatic then
        T.ColRef:setKinematic(true)
    end

    return T
end

function mt.__remove(self)
    Physics.DequeueToSyncLTJ(self)
    Physics.UnbindCollider(self.WId,self.ColRef)

    self.Touched:Destroy()
    self.TouchEnded:Destroy()
    self.Entity = nil

    self.ColRef:setUserData(nil)
    self.ColRef:destroy()
    self.ColRef:release()
    for i in pairs(self) do
        self[i] = nil
    end
end

Collider.FinalProcessing = function()
    if Component.TransformRequired then
        table.insert(Component.TransformRequired,Collider.Name)
    end
end

return Collider
