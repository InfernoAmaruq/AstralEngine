local Entity = GetService("Entity", "Entity")
local Component = GetService("Component","Component")
local NewWorld = lovr.physics.newWorld

local Physics = {}

local N = 1
Physics.Worlds = {}
Physics.RawWorlds = {}

local ParamsList = require("./Params")
for i,v in pairs(ParamsList) do
    Physics[i] = v
end

-- PHYS CONFIG
local WorldColliders = table.alloc(5, 0)
local LuaToJoltToSync = table.alloc(5, 0)

@flag:F_Col = 1;
@flag:F_Trans = 2;
@flag:F_Flags = 3;

@flag:S_Static = 0b101100000001;
@flag:S_Kinematic = 0b101100000010;

@flag:SHOULD_MOVE = 0b101100000011;

local CALLBACKS = {
    Enter = function(a,b,c)
        local PtrA, PtrB = a:getUserData(), b:getUserData()
        PtrA.Touched:Fire(PtrB.Entity,c)
        PtrB.Touched:Fire(PtrA.Entity,c)
    end,
    Exit = function(a,b)
        local PtrA, PtrB = a:getUserData(), b:getUserData()
        PtrA.TouchEnded:Fire(PtrB.Entity,c)
        PtrB.TouchEnded:Fire(PtrA.Entity,c)
    end,
}

local DefaultParameters = { ThreadSafe = false, RestitutionThreshold = 1, Stabilization = .7, Callbacks = {
    Enter = CALLBACKS.Enter, Exit = CALLBACKS.Exit
}, SetCollisionBetween = {},
    Tags = {"DEFAULT"}, StaticTags = {"STATIC_DEFAULT"}
}

function Physics.NewWorld(Parameters)
    Parameters = Parameters or DefaultParameters

    local Tags, StaticTags = Parameters.Tags or DefaultParameters.Tags, Parameters.StaticTags or DefaultParameters.StaticTags

    for _, Tag in pairs(StaticTags) do
        table.insert(Tags,Tag)
    end

    AstralEngine.Assert(#Tags <= 31,"Too many tags passed when creating world!\n"..table.concat(Tags,"\n"),"PHYSICS")

    local W = NewWorld{
        tags = Tags,
        staticTags = StaticTags,
        maxColliders = Parameters.MaxColliders,
        threadSafe = Parameters.ThreadSafe or DefaultParameters.ThreadSafe,
        allowSleep = Parameters.AllowSleep,
        stabilization = Parameters.Stabilization or DefaultParameters.Stabilization,
        maxPenetration = Parameters.MaxPenetration,
        restitutionThreshold = Parameters.RestitutionThreshold or DefaultParameters.RestitutionThreshold,
        velocitySteps = Parameters.VelocitySteps,
        positionSteps = Parameters.PositionSteps,
    }

    W:setCallbacks{
        exit = (Parameters.Callbacks or DefaultParameters.Callbacks).Exit,
        enter = (Parameters.Callbacks or DefaultParameters.Callbacks).Enter
    }

    for Tag, List in pairs(Parameters.SetCollisionBetween) do
        for Tag2, State in pairs(List) do

            if State then
                W:enableCollisionBetween(Tag,Tag2)
            else
                W:disableCollisionBetween(Tag,Tag2)
            end
        end
    end

    assert(W, "Failed to create world!")

    local T = Entity.New("WORLD_" .. N)
    T:AddComponent("World", { W = W, N = N, D = Parameters.DefaultTag or nil, STATIC = StaticTags, TAGS = Tags })

    Physics.Worlds[N] = T
    Physics.RawWorlds[N] = W

    WorldColliders[N] = { [&F_Col] = table.alloc(250,0), [&F_Trans] = table.alloc(250,0), [&F_Flags] = table.alloc(250,0) }
    LuaToJoltToSync[N] = { [&F_Col] = table.alloc(70,0), [&F_Trans] = table.alloc(70,0) }

    N = N + 1
    return T
end

function Physics.DestroyWorld(WorldEntity, KillEntity, FromComp)
    local Comp = WorldEntity:GetComponent("World")

    local WorldId = Comp.WorldId
    if not Physics.Worlds[WorldId] then return end

    Physics.Worlds[WorldId] = nil
    Physics.RawWorlds[WorldId] = nil
    WorldColliders[WorldId] = nil
    LuaToJoltToSync[WorldId] = nil

    if WorldId == N and N > 0 then N = N - 1 end

    if not FromComp then
        WorldEntity:RemoveComponent("World")
    end
    if KillEntity then
        WorldEntity:Destroy()
    end
end

local StoredComponents = {
    --[COMPONENTNAME] = SIZEFIELD
}

function Physics.BindSizeComponent(ComponentName, Field)
    StoredComponents[ComponentName] = Field
end

function Physics.GetObjSize(e)
    for i, v in pairs(Component.SetComponents[e]) do
        if StoredComponents[i] then
            return v[StoredComponents[i]]
        end
    end
    return nil
end

local FF_GetPose, FF_FromPose, CC_SetPose, CC_SetVel, CC_SetAngVel

local FieldToFlag = {
    Kinematic = &S_Kinematic,
    Static = &S_Static
}

local function ProcessFlags(ColRef)
    local Flags = 0
    for i,v in pairs(FieldToFlag) do
        local FIELD = ColRef[i]
        if FIELD then
            Flags |= v
        end
    end
    return Flags
end

function Physics.BindCollider(WId, ColRef, Transform)
    local Col = ColRef.ColRef
    if not FF_GetPose or not FF_FromPose then
        FF_GetPose = Col.getPose
        FF_FromPose = Transform.FromPose
        CC_SetPose = Col.setPose
        CC_SetVel = Col.setLinearVelocity
        CC_SetAngVel = Col.setAngularVelocity
    end

    local Flags = ProcessFlags(ColRef)

    table.insert(WorldColliders[WId][&F_Col], Col)
    table.insert(WorldColliders[WId][&F_Trans], Transform)
    table.insert(WorldColliders[WId][&F_Flags],Flags)
end

function Physics.UpdateSyncField(WId, ColliderRef, Field, Value)
    local FlagVal = FieldToFlag[Field]
    if not FlagVal then return end

    local Id

    for i,v in pairs(WorldColliders[WId][&F_Col]) do
        if v == ColliderRef then Id = i break end
    end

    if not Id then return end
    local t = WorldColliders[WId][&F_Flags]

    if Value then
        t[Id] |= FlagVal
    else
        t[Id] &= ~FlagVal
    end
end

function Physics.UnbindCollider(WId, v)
    local Index = table.find(WorldColliders[WId][&F_Col],v) or table.find(WorldColliders[WId][&F_Trans],v)
    if not Index then return end
    local Max = #WorldColliders[WId][&F_Col]
    WorldColliders[WId][&F_Col][Index] = WorldColliders[WId][&F_Col][Max]
    WorldColliders[WId][&F_Trans][Index] = WorldColliders[WId][&F_Trans][Max]
    WorldColliders[WId][&F_Flags][Index] = WorldColliders[WId][&F_Flags][Max]
    WorldColliders[WId][&F_Col][Max] = nil
    WorldColliders[WId][&F_Trans][Max] = nil
    WorldColliders[WId][&F_Flags][Max] = nil
end

local MainWorld, MainWorldId

function Physics.SetMainWorld(W)
    W = W and W.__id and Component.SetComponents[W.__id]["World"] or W

    MainWorld = W and W.World or nil
    MainWorldId = W and W.WorldId or nil
    if Physics.__OnWorldReset then
        Physics.__OnWorldReset(MainWorld, MainWorldId)
    end
end

function Physics.GetMainWorld(b)
    return b and Physics.Worlds[MainWorldId] or MainWorld, MainWorldId
end

function Physics.UpdateTransforms(World)
    local Entry = WorldColliders[World]
    local Colls, Trans, Flags = Entry[&F_Col], Entry[&F_Trans], Entry[&F_Flags]
    local n = #Colls
    local FromPose, GetPose = FF_FromPose, FF_GetPose
    for i = 1, n do
        if (Flags[i] & &SHOULD_MOVE) ~= 0 then continue end
        FromPose(Trans[i],GetPose(Colls[i]))
    end
end

function Physics.DequeueToSyncLTJ(Col)
    local t = LuaToJoltToSync[Col.WId]
    Col = Col.ColRef

    local SelfPtr = nil
    for i = 1, #t[&F_Col] do
        if t[&F_Col][i] == Col then SelfPtr = i break end
    end
    if not SelfPtr then return end

    t[&F_Col][SelfPtr] = t[&F_Col][#t[&F_Col]]
    t[&F_Trans][SelfPtr] = t[&F_Trans][#t[&F_Trans]]
    t[&F_Trans][#t[&F_Trans]] = nil
    t[&F_Col][#t[&F_Col]] = nil
end

function Physics.QueueToSyncLTJ(W,Col,Transform)
    local t = LuaToJoltToSync[W]

    local a = t[&F_Col]
    for i = 1, #a do
        if a[i] == Col then return end
    end

    table.insert(t[&F_Col],Col)
    table.insert(t[&F_Trans],Transform)
end

function Physics.LuaToJolt(World)
    local Entry = LuaToJoltToSync[World]

    local ColT, TransT = Entry[&F_Col], Entry[&F_Trans]

    local n = #ColT

    for i = n, 1, -1 do
        CC_SetPose(ColT[i], TransT[i][1], TransT[i][2])
        ColT[i] = nil; TransT[i] = nil
    end
end

GetService.AddService("Physics", Physics)
return Physics
