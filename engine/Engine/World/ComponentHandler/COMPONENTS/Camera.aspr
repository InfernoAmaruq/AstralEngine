local Camera = {}

local Renderer = GetService("Renderer")
local Component = GetService("Component")

local TextureConfig = { samples = 1, usage = { "render", "sample" }, mipmaps = false }
local TexConf2 = { samples = 1, usage = { "render", "sample" }, mipmaps = false, format = "rgba16f" }

local TEXCTR = 5 -- number of textures used in the camera

Camera.Name = "Camera"
Camera.Pattern = {
    FOV = math.rad(70),
    Far = 0,
    Near = 0.05,
    Orthographic = false,
    CameraMask = Renderer.CamMask,
    Lighting = ENUM.LightingTechnology.Cel,
    DrawToScreen = false,
    CameraPass = nil,
    CameraTex = nil,
    SolidTex = nil,
    OITTex = nil,
    ViewCull = true,
    BackfaceCulling = true,
    NearestSampler = false,
    Enabled = true,
    QueueUpd = false,
    RenderCallback = nil,
    OITPass = nil,
    SolidPass = nil,

    --METHODS
    SetResolution = nil,
}
Camera.Metadata = {}

local FIELDS = {
    CameraMask = 1,
    Orthographic = 2,
    Aspect = 3,
    Far = 4,
    Near = 5,
    FOV = 6,
    W = 7,
    Width = 7,
    H = 8,
    Height = 8,
    Lighting = 9,
    DrawToScreen = 10,
    CameraPass = 11,
    CameraTex = 12,
    OITTex = 13,
    ViewCull = 14,
    BackfaceCulling = 15,
    NearestSampler = 16,
    Enabled = 17,
    QueueUpd = 18,
    RenderCallback = 19,
    SolidTex = 20,
    OITPass = 21,
    SolidPass = 22,
    OITDepth = 23,
    DepthTexture = 24,
}

local function RawViewToRay(self, Vector) end

local function RawWorldToView() end

local METHODS = {
    SetResizeCallback = function(self, V1, V2)
        local TV1 = rtype(V1)
        local TV2 = rtype(V2)
        if TV1 == "function" then
        elseif TV1 == "table" and (TV2 == "table" or TV2 == "nil") then
        else
            AstralEngine.Log("Invalid type parameter passed to `SetResizeCallback`", "error", "CAMERA")
        end
    end,
    Resize = function(self, NewSize) end,
    ScreenPointToRay = function(self, V1, V2)
        local Vector = typeof(V1) == "Vec2" and V1 or vec2(V1, V2)
        Vector = vec2(Vector.x / self.W, Vector.y / self.H)

        RawViewToRay(self, Vector)
    end,
    ViewpointToRay = function(self, V1, V2)
        local Vector = typeof(V1) == "Vec2" and V1 or vec2(V1, V2)
        RawViewToRay(self, Vector)
    end,
}

local READ_ONLY = {
    Width = true,
    Height = true,
    Aspect = true,
}

local mt = {
    __index = function(self, k)
        local Val = FIELDS[k]
        if Val then
            return self[Val]
        end
        return METHODS[k]
    end,
    __newindex = function(self, k, v)
        if READ_ONLY[k] then
            AstralEngine.Error("Attempt to write to Read Only value on Camera component", "CAMERA")
        end
        rawset(self, FIELDS[k] or k, v)
    end,
}

local BasePriority = 42069
local BoundCameras = 0

local OIT_CONF = { format = "r16f", samples = 1, usage = { "render", "sample" }, mipmaps = false }
local DEPTH_CONF = { format = "d32f", samples = 1, usage = { "render", "sample" }, mipmaps = false, linear = true }

local function RebuildTexture(V, w, h)
    local OldV = V[1]
    local NewV = AstralEngine.Graphics.NewRawTexture(w, h, V.__CAPTURE[3])
    V[1] = NewV
    local CamRef = V.CREF
    CamRef.__REBUILT_TEX = (CamRef.__REBUILT_TEX or 0) + 1
    local v = false
    if CamRef.__REBUILT_TEX > TEXCTR then
        AstralEngine.Log("FATAL: __REBUILT_TEX COUNTER OVERFLOW OVER TEXCTR CONSTANT", "error", "CAMERA")
    elseif CamRef.__REBUILT_TEX == TEXCTR then
        v = true
    end
    OldV:release()
    return v
end

local function RebuildPasses(CameraRef)
    CameraRef.__REBUILT_TEX = 0

    CameraRef.CameraPass[1] = AstralEngine.Graphics.NewRawPass({ CameraRef.CameraTex[1] })
    CameraRef.SolidPass[1]:setCanvas({
        CameraRef.SolidTex[1],
        depth = CameraRef.DepthTexture[1],
        samples = 1,
    })
    CameraRef.OITPass[1]:setCanvas({
        CameraRef.OITTex[1],
        CameraRef.OITDepth[1],
        depth = CameraRef.DepthTexture[1],
        samples = 1,
    })
end

local function Rebuild(V, IsPass, w, h)
    if not IsPass then
        local PassesReady = RebuildTexture(V, w, h)
        if PassesReady then
            RebuildPasses(V.CREF)
            V.CREF[FIELDS.W] = w
            V.CREF[FIELDS.H] = h
            V.CREF[FIELDS.Aspect] = w / h
        end
    end
end

Camera.Metadata.__create = function(Input, Entity, Sink)
    if not Sink and not Component.HasComponent(Entity, "Transform") then
        Component.AddComponent(Entity, "Transform", { Position = vec3(), Orientation = quat() })
    end

    local REBUILD_CALLBACK = Input.RebuildCallback or Rebuild

    local Data = {}

    local W, H = (Input.Resolution or vec2(AstralEngine.Window.W, AstralEngine.Window.H)):unpack()
    local Texture = AstralEngine.Graphics.NewTexture(W, H, TextureConfig)
    local OITTex = AstralEngine.Graphics.NewTexture(W, H, TexConf2)
    local OITDepth = AstralEngine.Graphics.NewTexture(W, H, OIT_CONF)
    local SolidTex = AstralEngine.Graphics.NewTexture(W, H, TextureConfig)
    local DepthTexture = AstralEngine.Graphics.NewTexture(W, H, DEPTH_CONF)

    Data.W = W
    Data.H = H
    Data.Aspect = W / H

    OITTex.ResizeCallback = REBUILD_CALLBACK
    OITDepth.ResizeCallback = REBUILD_CALLBACK
    SolidTex.ResizeCallback = REBUILD_CALLBACK
    DepthTexture.ResizeCallback = REBUILD_CALLBACK
    Texture.ResizeCallback = REBUILD_CALLBACK

    Data.CameraPass = AstralEngine.Graphics.NewPass({ Texture[1] })
    Data.CameraTex = Texture
    Data.OITTex = OITTex
    Data.OITDepth = OITDepth
    Data.SolidTex = SolidTex
    Data.DepthTexture = DepthTexture
    Data.OITPass =
        AstralEngine.Graphics.NewPass({ OITTex[1], OITDepth[1], depth = { texture = DepthTexture[1] }, samples = 1 })
    Data.SolidPass = AstralEngine.Graphics.NewPass({ SolidTex[1], depth = { texture = DepthTexture[1] }, samples = 1 })

    Data.OITPass:setClear({ { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, depth = false })

    Data.OITPass.ResizeCallback = REBUILD_CALLBACK
    Data.CameraPass.ResizeCallback = REBUILD_CALLBACK
    Data.SolidPass.ResizeCallback = REBUILD_CALLBACK

    Renderer.AddCamera(Entity)
    Renderer.PassStorage.AddPass(false, Data.SolidPass, BasePriority + BoundCameras, true)
    Renderer.PassStorage.AddPass(false, Data.OITPass, BasePriority + BoundCameras + 1, true)
    Renderer.PassStorage.AddPass(false, Data.CameraPass, BasePriority + BoundCameras + 2, true)

    for i, v in pairs(Input) do
        if not Data[i] then
            Data[i] = v
        end
    end

    for i, v in pairs(Camera.Pattern) do
        if not Data[i] then
            Data[i] = rtype(v) == "function" and v() or v
        end
    end

    local D = setmetatable({}, mt)

    Data.OITDepth.CREF = D
    Data.OITPass.CREF = D
    Data.OITTex.CREF = D
    Data.SolidPass.CREF = D
    Data.SolidTex.CREF = D
    Data.CameraPass.CREF = D
    Data.CameraTex.CREF = D
    Data.DepthTexture.CREF = D

    for i, v in pairs(Data) do
        if not FIELDS[i] then
            continue
        end
        rawset(D, FIELDS[i], v)
        print("CAM: SET FIELD:", i, FIELDS[i], v)
    end

    BoundCameras = BoundCameras + 3

    return D
end

Camera.Metadata.__remove = function(self, Entity)
    Renderer.RemoveCamera(Entity)
end

return Camera
