local Camera = {}

-- nts: add MSAA

local Renderer = GetService("Renderer")
local Component = GetService("Component")

local MSAASolid = { samples = 4, usage = { "render", "sample" }, mipmaps = false }
local TextureConfig = { samples = 1, usage = { "render", "sample" }, mipmaps = false }
local TexConf2 = { samples = 4, usage = { "render", "sample" }, mipmaps = false, format = "rgba16f" }

local TEXCTR = 5 -- number of textures used in the camera

Camera.Name = "Camera"
Camera.Pattern = {
    RadFOV = math.rad(70),
    Far = 0,
    Near = 0.05,
    Orthographic = false,
    CameraMask = Renderer.CamMask,
    Lighting = ENUM.LightingTechnology.Cel,
    DrawToScreen = false,
    CameraPass = nil,
    CameraTex = nil,
    SolidTex = nil,
    OITTex = nil,
    ViewCull = true,
    BackfaceCulling = true,
    NearestSampler = false,
    Enabled = true,
    QueueUpd = false,
    RenderCallback = nil,
    OITPass = nil,
    SolidPass = nil,

    --METHODS
    SetResolution = nil,
}
Camera.Metadata = {}

local FIELDS = {
    CameraMask = 1,
    Orthographic = 2,
    Aspect = 3,
    Far = 4,
    Near = 5,
    RadFOV = 6,
    W = 7,
    Width = 7,
    H = 8,
    Height = 8,
    Lighting = 9,
    DrawToScreen = 10,
    CameraPass = 11,
    CameraTex = 12,
    OITTex = 13,
    ViewCull = 14,
    BackfaceCulling = 15,
    NearestSampler = 16,
    Enabled = 17,
    QueueUpd = 18,
    RenderCallback = 19,
    SolidTex = 20,
    OITPass = 21,
    SolidPass = 22,
    OITDepth = 23,
    DepthTexture = 24,
    Density = 25,
}

local function RawViewToRay(self, Vector)
    local NDCx = Vector.x * 2 - 1
    local NDCy = 1 - Vector.y * 2

    local Aspect = self[FIELDS.Aspect]

    local FOV = self[FIELDS.RadFOV]
    local TanHalf = math.tan(FOV * 0.5)

    local x = NDCx * TanHalf * Aspect
    local y = NDCy * TanHalf

    local EntPtr = self.__EntityPtr
    local Transform = EntPtr.Transform

    local Forward, Right, Up = Transform.ForwardVector, Transform.RightVector, Transform.UpVector

    local Dir = vec3(Forward + Right * x + Up * y):normalize()

    return Transform.Position, Dir
end

local function RawWorldToView(self, Pos)
    local Transform = self.__EntityPtr.Transform

    local CamPos = Transform.Position
    local CamRot = Transform.Orientation

    local LocalPos = Pos - CamPos
    local View = CamRot:conjugate() * LocalPos

    if View.z >= 0 then
        return nil
    end

    local Aspect = self[FIELDS.Aspect]
    local TanHalf = math.tan(self[FIELDS.RadFOV] * 0.5)

    local NDCx = (View.x / -View.z) / (TanHalf * Aspect)
    local NDCy = (View.y / -View.z) / TanHalf

    local UVX = NDCx * 0.5 + 0.5
    local UVY = 1 - (NDCy * 0.5 + 0.5)
    return vec2(UVX, UVY)
end

local METHODS = {
    Resize = function(self, NewSize, Density)
        Density = Density or lovr.system.getWindowDensity()
        for _, v in ipairs(self.__Resizables) do
            v.ResizeCallback(v, v.__IsPass, NewSize.x, NewSize.y, Density)
        end
    end,
    ScreenPointToRay = function(self, V1, V2)
        local Vector = typeof(V1) == "Vec2" and V1 or vec2(V1, V2)
        Vector = vec2(Vector.x / self.Resolution.x, Vector.y / self.Resolution.y)

        return RawViewToRay(self, Vector)
    end,
    ViewpointToRay = function(self, V1, V2)
        local Vector = typeof(V1) == "Vec2" and V1 or vec2(V1, V2)
        return RawViewToRay(self, Vector)
    end,
    WorldToViewpoint = function(self, Pos)
        return RawWorldToView(self, Pos)
    end,
    WorldToScreenPoint = function(self, Pos)
        local V = RawWorldToView(self, Pos)

        if not V then
            return nil
        end

        return V * self.Resolution
    end,
}

local READ_ONLY = {
    Width = true,
    Height = true,
    Aspect = true,
    Density = true,
}

local SETTER = {
    FOV = function(self, FieldOfView)
        rawset(self, FIELDS.RadFOV, math.rad(FieldOfView))
    end,
    DrawToScreen = function(self, Val)
        if Renderer.SetPrimaryCamera then
            Renderer.SetPrimaryCamera(Val and self or nil)
        else
            AstralEngine.Error("CANNOT SET PRIMARY CAMERA, FUNCTION MISSING", "CAMERA", 2)
        end
    end,
}
local GETTER = {
    FOV = function(self)
        return math.deg(self[FIELDS.RadFOV])
    end,
    Resolution = function(self)
        return vec2(self[FIELDS.W], self[FIELDS.H]) / self[FIELDS.Density]
    end,
    TrueResolution = function(self)
        return vec2(self[FIELDS.W], self[FIELDS.H])
    end,
}

local mt = {
    __index = function(self, k)
        if GETTER[k] then
            return GETTER[k](self)
        end
        local Val = FIELDS[k]
        if Val then
            return self[Val]
        end
        return METHODS[k]
    end,
    __newindex = function(self, k, v)
        if SETTER[k] then
            return SETTER[k](self, v)
        end
        if READ_ONLY[k] then
            AstralEngine.Error("Attempt to write to Read Only value on Camera component", "CAMERA")
        end
        rawset(self, FIELDS[k] or k, v)
    end,
}

local BasePriority = 42069
local BoundCameras = 0

local OIT_CONF = { format = "rg16f", samples = 4, usage = { "render", "sample" }, mipmaps = false }
local DEPTH_CONF = { format = "d32f", samples = 4, usage = { "render", "sample" }, mipmaps = false, linear = true }

local function RebuildTexture(V, w, h)
    local OldV = V[1]
    local NewV = AstralEngine.Graphics.NewRawTexture(w, h, V.__CAPTURE[3])
    V[1] = NewV
    local CamRef = V.CREF
    CamRef.__REBUILT_TEX = (CamRef.__REBUILT_TEX or 0) + 1
    local v = false
    if CamRef.__REBUILT_TEX > TEXCTR then
        AstralEngine.Log("FATAL: __REBUILT_TEX COUNTER OVERFLOW OVER TEXCTR CONSTANT", "error", "CAMERA")
    elseif CamRef.__REBUILT_TEX == TEXCTR then
        v = true
    end
    OldV:release()
    return v
end

local function RebuildPasses(CameraRef)
    CameraRef.__REBUILT_TEX = 0

    CameraRef.CameraPass[1]:setCanvas({
        CameraRef.CameraTex[1],
        depth = CameraRef.CameraPass[1]:getCanvas().depth,
        samples = 1,
    })
    CameraRef.SolidPass[1]:setCanvas({
        CameraRef.SolidTex[1],
        depth = CameraRef.DepthTexture[1],
        samples = 1,
    })
    CameraRef.OITPass[1]:setCanvas({
        CameraRef.OITTex[1],
        CameraRef.OITDepth[1],
        depth = CameraRef.DepthTexture[1],
        samples = 1,
    })
end

local function Rebuild(V, IsPass, w, h, Density)
    Density = Density or lovr.system.getWindowDensity()
    w = w * Density
    h = h * Density
    if not IsPass then
        local PassesReady = RebuildTexture(V, w, h)
        if PassesReady then
            RebuildPasses(V.CREF)
            V.CREF[FIELDS.W] = w
            V.CREF[FIELDS.H] = h
            V.CREF[FIELDS.Aspect] = w / h
            V.CREF[FIELDS.Density] = Density
        end
    end
end

Camera.Metadata.__create = function(Input, Entity, Sink)
    if not Sink and not Component.HasComponent(Entity, "Transform") then
        Component.AddComponent(Entity, "Transform", { Position = vec3(), Orientation = quat() })
    end

    local REBUILD_CALLBACK = Input.RebuildCallback or Rebuild

    local Data = {}

    local W, H = (Input.Resolution or vec2(AstralEngine.Window.W, AstralEngine.Window.H)):unpack()

    local Density = Input.Density or lovr.system.getWindowDensity()
    Data.Density = Density

    local Texture = AstralEngine.Graphics.NewTexture(W, H, TextureConfig)
    local OITTex = AstralEngine.Graphics.NewTexture(W, H, TexConf2)
    local OITDepth = AstralEngine.Graphics.NewTexture(W, H, OIT_CONF)
    local SolidTex = AstralEngine.Graphics.NewTexture(W, H, MSAASolid)
    local DepthTexture = AstralEngine.Graphics.NewTexture(W, H, DEPTH_CONF)

    W = W * Density
    H = H * Density

    Data.W = W
    Data.H = H
    Data.Aspect = W / H
    Data.RadFOV = Input.RadFOV or math.rad(Input.FOV)

    OITTex.ResizeCallback = REBUILD_CALLBACK
    OITDepth.ResizeCallback = REBUILD_CALLBACK
    SolidTex.ResizeCallback = REBUILD_CALLBACK
    DepthTexture.ResizeCallback = REBUILD_CALLBACK
    Texture.ResizeCallback = REBUILD_CALLBACK

    Data.CameraPass = AstralEngine.Graphics.NewPass({ Texture[1], samples = 1 })
    Data.CameraTex = Texture
    Data.OITTex = OITTex
    Data.OITDepth = OITDepth
    Data.SolidTex = SolidTex
    Data.DepthTexture = DepthTexture
    Data.OITPass =
        AstralEngine.Graphics.NewPass({ OITTex[1], OITDepth[1], depth = { texture = DepthTexture[1] }, samples = 4 })
    Data.SolidPass = AstralEngine.Graphics.NewPass({ SolidTex[1], depth = { texture = DepthTexture[1] }, samples = 4 })

    Data.OITPass:setClear({ { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, depth = false })

    Data.OITPass.ResizeCallback = REBUILD_CALLBACK
    Data.CameraPass.ResizeCallback = REBUILD_CALLBACK
    Data.SolidPass.ResizeCallback = REBUILD_CALLBACK

    Data.__Resizables = setmetatable({
        OITTex,
        OITDepth,
        SolidTex,
        DepthTexture,
        Texture,
        HistoryTexture,
    }, { __mode = "v" })

    Renderer.AddCamera(Entity)
    Renderer.PassStorage.AddPass(false, Data.SolidPass, BasePriority + BoundCameras, true)
    Renderer.PassStorage.AddPass(false, Data.OITPass, BasePriority + BoundCameras + 1, true)
    Renderer.PassStorage.AddPass(false, Data.CameraPass, BasePriority + BoundCameras + 2, true)

    for i, v in pairs(Input) do
        if not Data[i] then
            Data[i] = v
        end
    end

    for i, v in pairs(Camera.Pattern) do
        if not Data[i] then
            Data[i] = rtype(v) == "function" and v() or v
        end
    end

    local D = setmetatable({}, mt)

    Data.OITDepth.CREF = D
    Data.OITPass.CREF = D
    Data.OITTex.CREF = D
    Data.SolidPass.CREF = D
    Data.SolidTex.CREF = D
    Data.CameraPass.CREF = D
    Data.CameraTex.CREF = D
    Data.DepthTexture.CREF = D

    for i, v in pairs(Data) do
        if i == "__Resizables" then
            rawset(D, i, v)
        elseif i == "DrawToScreen" then
            SETTER.DrawToScreen(D, v)
        else
            if not FIELDS[i] then
                continue
            end
            rawset(D, FIELDS[i], v)
        end
    end

    BoundCameras = BoundCameras + 3

    rawset(D, "__EntityPtr", GetService("World").GetEntityFromId(Entity))

    return D
end

Camera.Metadata.__remove = function(self, Entity)
    Renderer.RemoveCamera(Entity)
end

return Camera
